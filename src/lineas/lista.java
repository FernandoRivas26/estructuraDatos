package lineas;//PAQUETE LINEAS

public class lista {//CLASE PUBLICA LISTA
	private nodo cabeza=null;// VARIABLE PRIVADA DE TIPO NODO
	
	public nodo getCabeza(){//METODO PARA OBJETER EL VALOR DE LA CABEZA DE LA LISTA
		return cabeza;
	}
	public void setCabeza(nodo val){//METODO PARA DARLE EL VALOR A LA CABEZA DE LA LISTA
		this.cabeza=val;
	}
	public boolean isEmpty(){//METODO PARA COMPROBAR SI LA LISTA ESTA O NO VACIA
		
		boolean resp=false;//VARIABLE DE RETORNO TIPO BOOLEAN
		if(this.cabeza==null){// SI LA CABEZA ES IDENTICA A NULL
			resp=true;// ENVIA UN TRUE COMO RESPUESTA INDICANDO QUE LA LIST ESTA VACIA
		}
		return resp;//SI NO SE ENTRA A LA CONDISION RESP NUNCA CAMBIA SI VALOR Y SE QUEDA COMO FALSE INDICANDO QUE LA LISTA NO ESTA VACIA
	}
	public void busqueda(int valor){//METODO BUSQUEDA USADO PARA BUSCAR UN VALOR DENTRO DE LA LISTA. RECIBE COMO PARAMETRO UN VALOR INT
			nodo temporal = this.cabeza;//VARIABLE TEMPORAL DE TIPO NODO INICIANDO CON EL VALOR DE LA CABEZA O PRINCIPIO DE LA LISTA
			while(temporal.objeterSig()!=null){//MIENTRAS EL NODO SIGUIENTE DEL NODO TEMPORAL SEA DIFERENTE DE NULO SE SEGUIRA REPITENDO
				if(valor==temporal.obtenerVal()){//SI EL VALOR QUE BUSCAMOS ES IDENTICO A LO QUE CONTIENE EL NODO TEMPORAL
				System.out.println("El valor es "+valor);//DE SER ASI SE IMPRIME EL VALOR
				}else{//DE LO CONTRARIO SE HARA UN INCREMENTO EN EL NODO
					temporal=temporal.objeterSig();//NODO ES IGUAL A SI MISMO OBTENIENDO EL SIGUIENTE NODO ENLAZADO
				}
			}
	}
	public void insertar (int valor){//METODO QUE INSEERTA UN VALOR AL INICIO RECIBE COMO PARAMETRO IN VALOR ENTERO
		nodo nuevo = new nodo();//CREACION DE UNA VARIABLE DE TIPO DODO
		nuevo.setVal(valor);//LE DAREMOS A NUESTRO NUEVO NODO EL VALOR QUE RECIBIMOS COMO PARAMETRO
		nuevo.enlazarSig(null);//EL ENLAZAR SIGUIENTE SE IGUALA A NULO YA QUE ES EL PRIMER VALOR EN TODA LA LISTA
		this.cabeza=nuevo;//LA CABEZA SE IGUALA AL NODO NUEVO YA QUE COMO ES EL UNICO NODO ESTE ES LA CABEZA
	}
	public void insertarPrincipio (int valor){//METODO PARA INSERTAR UN VALOR AL PRICIPIO DE LA LISTA
		if(isEmpty()){//COMPARAMOS SI LA LISTA ESTA VACIA 
			insertar(valor);//DE SER CIERTO LLAMAEREMOS NUESTO METODO INSERTAR ENVIANDO COMO PARAMETRO LA VARIABLE VALOR
		}else{//DE LO CONTRARIO
			nodo nuevo = new nodo();//CREAREMOS UNA VARIABLE DE TIPO NODO LLAMADA NUEVO
			nuevo.setVal(valor);//NUESTRO NODO NUEVO ALMACENARA EL VALOR QUE ENVIAMOS COMO PARAMETRO
			nuevo.enlazarSig(this.cabeza);//EL NODO NUEVO SE ENLAZARA CON LA CABEZA YA QUE ESTE ESTA TOMANDO EL LUGAR DEL NODO ANTERIOR QUE ERA LA CABEZA
			this.cabeza=nuevo;//LA CABEZA SE IGUALARA A NUEVO
		}
	}
	public void insertarFinal(int valor){//METODO PARA INSERTAR UN VALOR EN LA ULTIMA POSICION O EN LA COLA
		if(isEmpty()){//SI LA LISTA ESTA VACIA
			insertar(valor);//MANDAREMOS LLAMAR EL METODO INSERTAR ENVIANDO COMO PARAMETRO EL VALOR RECIBIDO
		}else{//DE NO ESTAR VACIA
			nodo nuevo = new nodo();//CREAREMOS UN NUEVO NODO LLAMADO NUEVO
			nuevo.setVal(valor);//NUESTRO NODO NUEVO ALMACENRA EL VALOR ENVIADO POR PARAMETRO
			nuevo.enlazarSig(null);//YA QUE NUESTRO NODO NUEVO ES EL ULTIMO VALOR, ESTE ESTARA ELAZADO A NULO
			
			nodo temporal = this.cabeza;//CREAREMOS UNA VARIABLE DE TIPO NODO LLAMADA TEMPORAL, LA CUAL SE INICIALIZA CON EL VALOR DE LA CABEZA
			while(temporal.objeterSig()!=null){//RECORREREMOS LA LISTA HASTA LLEGAR AL FINAL PARA PODER HACER LA INSERCION DE NUESTRO NODO NUEVO
			//MIESTRAS TEMPORAL ESTE ENLAZADO A UN NODO DIFERENTE DE NULO SE AVANZARA DE NODO	
				temporal=temporal.objeterSig();//TEMPORAL ES IGUAL A EL VALOR SIGUIENTE DE TEMPORAL.
			}
			temporal.enlazarSig(nuevo);	//UNA VEZ ENONTRADA LA COLA, ENLAZAREMOS LA ANTIGUA COLA A NUESTRO NODO NUEVO
		}
	}
	public StringBuilder printls(){//IMPRESION DE LA LISTA MEDIANTE LA HERRAMIENTA DE STRING BUILDER O CONTRUCTOR DE CADENAS
		StringBuilder cadena = new StringBuilder();//CREAMOS UNA INSTANCIA DE LA CLASE STRINGBULDER LLAMADA CADENA
		cadena.append("Cabeza ---->");//SE LE CONCATENARA O SUMARA A CADENA EL VALOR EN PARENTESIS
		nodo temporal = this.cabeza;//CREACION DE UNA VARIABLE TEMPORAL DE TIPO NODO INICIANDO EN EL VALOR DE CABEZA
		while(temporal!=null){//MIESTRAS TEMPORAL SEA DIFERENTE DE NULO
			cadena.append(temporal.obtenerVal()+"--->");//CONCATENAREMOS A LA VARIABLE CADENA EL VALOR ALMACENADO POR EL NODO TEMPORAL
			temporal=temporal.objeterSig();//INCREMENTAREMOS TEMPORAL
		}
		cadena.append("Null");//AL FINAL CONCATENAREMOS UN TEXTO DICIENDO NULO 
		return cadena;// REGRESAMOS EL VALOR DE CADENA PARA DESPUES SER IMPRESO POR CONSOLA
	}
	public boolean delete(int pos){//METODO PARA ELIMINAR UN NODO
		boolean flag=false;//VARIABLE DE TIPO BOOLEAN QUE INDICARA SI SI SE ELIMINO EL NODO O NO
		int n = contar();//CREAREMOS UNA VARIABLE N DE TIPO ENTERO CON UN VALOR INICIAL IGUAL A LO QUE REGRESE EL METODO CONTAR.
		if(isEmpty()){//SI LA LISTA ESTA VACIA AUTOMATICAMENTE ENCIAREMOS UN FALSE YA QUE NO HAY VALORES POR ELIMINAR
			flag=false;//LA VARIABLE BOOLEANA ES IGUAL AL FALSE
		}else if (n==1){//PERO SI NO SE PREGUNTA SI N ES IGUAL A 1 ES DECIR QUE LA LISTA SOLO TIENE UN DATO
			this.setCabeza(this.cabeza.objeterSig());//DAREMOS A CABEZA EL VALOR DE EL NODO SIGIENTE QUE EN TO DO CASO ES NULO YA QUE ES EL UNICO NODO DENTRO DE LA LINEA
		}else{//DE LO CONTRARIO
			temporal.enlazarSig(temporal.objeterSig().objeterSig());//SE ENLAZARA NUESTRO NODO TEMPORAL A LO QUE ESTA ENLAZADO A SU SIGUIENTE POSICION ES DECIR DOS POSICIONES ADELANTE
			flag=true;//COMO SI SE ELIMINO EL NODO LA VARIABLE BOOLEAN SE IGUALA A TRUE
		}
		
		return flag;//RETORNO DE LA VARIABLE BOOLEAN.
	}
	public  int contar(){//METODO CONTAR PARA SABER CUANTOS NODOS EXISTEN EN LA LISTAS
		int resp=0;//SE CREA UN CONTADOR LLAMADO RESP
		nodo temporal = this.cabeza;//UN NODO TEMPORAL INICIANDO DESDE LA CABEZA
		while(temporal.objeterSig()!=null){//MIENTRAS TEMPORAL ESTE ENLAZADO A UN VALOR DIFERENTE DE NULO ES DECIR QUE NO SEA LA COLA
			resp++;//INCREMENTAREMOS NUESTRO CONTADOR EN 1
			temporal=temporal.objeterSig();//INCREMENTAREMOS EL NODO AVANZANDO UNA POSICION
			}
		return resp;// RETORNAMOS LA VARIABLE RESP O NUESTRO CONTADOR
	}
	public void insertarPos(int valor, int pos){//METODO PARA INSERTAR UN NODO EN UNA POSICION ESPECIFICA
		if(pos>0 && this.contar()>0 && pos<=this.contar()){
			/*COMPARAMOS SI LA POSICION EN LA QUE QUEREMOS INSERTAR ES MAYOR A CERO Y SI LA LISTA TIENE MAS DE 0 POSICIONES
			 * Y SI LA POSICION ES MENOR IGUAL A LO EL NUEMOR DE NODOS EN LA LISTA, TO DO ESTO PASA GARANTIZAR QUE 
			 * SEA POSIBLE LA INSERSION DE UN DATO COMPROBANDO QUE LA LISTA NO ESTA VACIA O QUE LA POSICION REQUERIDA
			 * AL MENOS EXISTA*/
			if(pos==1){//SI LA POSICION EN DONDE DESEAMOS INSERTAR ES IGUAL A UNO ES DECIR AL PRINCIPIO
				this.insertarPrincipio(valor);//MANDAMOS LLAMAR AL METODO INSERTARPRINCIPIO CON EL VALOR QUE DESEAMOS INSERTAR
			}else if(pos==contar()){//DEÂº LOCONTRARIO SI POS ES IGUAL A EL NUMERO DE NODOS, ES DECIR A LA ULTIMA POSICION
				this.insertarFinal(valor);//MANDAMOS LLAMAR AL METOOD INSERTARFINAL CON EL VALOR A INSERTAR
			}else{//DE LO CONTRARIO
			nodo nuevo = new nodo();//VARIABLE NUEVO DE TIPO NODO
			nuevo.setVal(valor);//NEVO ALMACENARA EL VALOR DE LA VARIABLE ENVIADA COMO PARAMETRO
			nuevo.enlazarSig(anterior.objeterSig());//NUEVO ESTARA ENLAZADO A EL NODO QUE SIGUE DEL NODO ANTERIOR
			anterior.enlazarSig(nuevo);//ANTERIOR ESTARA ENLAZADO AL NUEVO
			}
		}
	}
		public boolean localizar(int valor){//LOCALIZAR UN VALOR, VERIFICAR QUE DICHO VALOR SE ENCUENTRE EN LA LISTA
		boolean resp=false;//VARIABLE BOOLEAN QUE SE REGRESA TRUE SI SE ENCONTRO
		nodo temporal=this.cabeza;//VARIABLE TEMPORAL DE TIPO NODO INICIALIZADA EN CABEZA
		while(temporal!=null){//RECORREREMOS TODA LA LISTA HASTA QUE TEMPORAL SEA NULO
			if(temporal.obtenerVal()==valor){//SI LO QUE ALMACENA EL NODO TEMPORAL ES IGUAL A LO QUE ESTAMOS BUSCANDO CAMBIAREMOS EL VALOR DE LA VARIABLE BOOLEAN
				resp=true;//CAMBIO DE VARIABLE
			}else{//DE LO CONTRARIO
				temporal=temporal.objeterSig();//INCREMENTO EN EL NODO TEMPORAL, AVANZAMOS UNO ENLA LISTA
			}
		}
		return resp;//RETORNO DE LA VARIABLE BOOLEAN
	}
}
